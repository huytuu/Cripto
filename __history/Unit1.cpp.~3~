//---------------------------------------------------------------------------

#pragma hdrstop
#include <string>

#include "Unit1.h"
//----------------------------------------------

string cifraCesarMixto(string mensaje, int clave) {
	string cifrado = "";
	for (char& c : mensaje) {
		if (isalpha(c)) {
			int base = islower(c) ? 'a' : 'A';
			cifrado += static_cast<char>((c - base + clave) % 26 + base);
		} else {
			cifrado += c;
		}
	}
	return cifrado;
}

int main() {
	string mensaje;
	int clave;

	cout << "Ingrese el mensaje a cifrar: ";
	getline(cin, mensaje);
	cout << "Ingrese la clave para cifrar: ";
	cin >> clave;

	string cifrado = cifraCesarMixto(mensaje, clave);
	cout << "Mensaje cifrado: " << cifrado << endl;

	return 0;
}

// Constructor que inicializa la clave
CVigenere::CVigenere(const std::wstring& key) : key_(key) {
	// Inicializar el alfabeto y los mapeos
	initializeAlphabet();
}

// Inicializa el alfabeto español y los mapeos correspondientes
void CVigenere::initializeAlphabet() {
    // Alfabeto español en mayúsculas y minúsculas
    alphabet_upper_ = L"ABCDEFGHIJKLMNÑOPQRSTUVWXYZ";
    alphabet_lower_ = L"abcdefghijklmnñopqrstuvwxyz";
    alphabet_size_ = alphabet_upper_.size();

    // Crear mapeos de caracteres a índices
    for (size_t i = 0; i < alphabet_size_; ++i) {
        char_to_index_[alphabet_upper_[i]] = i;
        char_to_index_[alphabet_lower_[i]] = i;
        index_to_char_upper_[i] = alphabet_upper_[i];
        index_to_char_lower_[i] = alphabet_lower_[i];
    }
}

// Implementación del método para cifrar (encriptar) un texto
std::wstring CVigenere::encrypt(const std::wstring& text) {
    std::wstring result;
    size_t key_length = key_.length();
    for (size_t i = 0, j = 0; i < text.length(); ++i) {
        wchar_t c = text[i];
        if (isSpanishLetter(c)) {
            wchar_t k = key_[j % key_length];
            size_t c_index = char_to_index_[c];
            size_t k_index = char_to_index_[k];
            size_t encrypted_index = (c_index + k_index) % alphabet_size_;
            if (iswupper(c)) {
                c = index_to_char_upper_[encrypted_index];
            } else {
                c = index_to_char_lower_[encrypted_index];
            }
			j++;
        }
        result += c;
    }
    return result;
}

// Implementación del método para descifrar un texto
std::wstring CVigenere::decrypt(const std::wstring& text) {
    std::wstring result;
    size_t key_length = key_.length();
    for (size_t i = 0, j = 0; i < text.length(); ++i) {
        wchar_t c = text[i];
        if (isSpanishLetter(c)) {
            wchar_t k = key_[j % key_length];
            size_t c_index = char_to_index_[c];
            size_t k_index = char_to_index_[k];
            size_t decrypted_index = (c_index + alphabet_size_ - k_index) % alphabet_size_;
            if (iswupper(c)) {
                c = index_to_char_upper_[decrypted_index];
            } else {
                c = index_to_char_lower_[decrypted_index];
            }
            j++;
        }
        result += c;
    }
    return result;
}

// Comprueba si un carácter es una letra del alfabeto español
bool CVigenere::isSpanishLetter(wchar_t c) {
    return char_to_index_.find(c) != char_to_index_.end();
}

#pragma package(smart_init)
